import numpy as np

from gameanalysis import aggfn
from gameanalysis import rsgame
from gameanalysis import utils


def _random_mask(prob, num_funcs, num_strats):
    """Returns a random mask that is valid

    Valid means that each row of the mast is neither all false or all true.

    Parameters
    ----------
    prob : float
        The probability of a strategy. Note, that this will actually be shifted
        slightly towards 0.5 because we ensure there are no rows with all false
        and all true.
    num_funcs : int
        The number of functions to return.
    num_strats : int
        The number of strategies to return.

    Returns
    -------
    mask : ndarray, shape (num_funcs, num_strats)
        The resulting balid mask.
    """
    vals = np.random.random((num_funcs, num_strats))
    mask = vals < prob
    inds = np.arange(num_funcs)
    mask[inds, vals.argmin(1)] = True
    mask[inds, vals.argmax(1)] = False
    return mask


def normal_aggfn(role_players, role_strats, functions, *, input_prob=0.2,
                 weight_prob=0.2):
    """Generate a random normal AgfnGame

    Each function value is an i.i.d Gaussian draw. For large numbers of players
    and small numbers of functions, this still produces relatively smooth
    deviation payoffs.

    Parameters
    ----------
    role_players : int or ndarray
        The number of players per role.
    role_strats : int or ndarray
        The number of strategies per role.
    functions : int
        The number of functions to generate.
    input_prob : float, optional
        The probability of a strategy counting towards a function value.
    weight_prob : float, optional
        The probability of a function producing non-zero payoffs to a strategy.
    """
    base = rsgame.emptygame(role_players, role_strats)
    inputs = _random_mask(input_prob, functions, base.num_strats).T
    weights = (_random_mask(weight_prob, functions, base.num_strats) *
               np.random.normal(0, 1, (functions, base.num_strats)))
    shape = (functions,) + tuple(base.num_role_players + 1)
    funcs = np.random.normal(0, 1, shape)
    return aggfn.aggfn_replace(base, weights, inputs, funcs)


def _random_aggfn(role_players, role_strats, functions, input_prob,
                  weight_prob, role_dist):
    """Base form for structured random aggfn generation

    role_dist takes a number of functions and a number of players and returns
    an ndarray of the function values.
    """
    base = rsgame.emptygame(role_players, role_strats)
    inputs = _random_mask(input_prob, functions, base.num_strats).T
    weights = (_random_mask(weight_prob, functions, base.num_strats) *
               np.random.normal(0, 1, (functions, base.num_strats)))

    funcs = np.ones((functions,) + tuple(base.num_role_players + 1))
    base_shape = [functions] + [1] * base.num_roles
    for r, p in enumerate(base.num_role_players):
        role_funcs = role_dist(functions, p)
        shape = base_shape.copy()
        shape[r + 1] = p + 1
        role_funcs.shape = shape
        funcs *= role_funcs
    return aggfn.aggfn_replace(base, weights, inputs, funcs)


def poly_aggfn(role_players, role_strats, functions, *, input_prob=0.2,
               weight_prob=0.2, degree=3):
    """Generate a random polynomial AgfnGame

    Functions are generated by generating `degree` zeros in [0, num_players] to
    serve as a polynomial functions.

    Parameters
    ----------
    role_players : int or ndarray
        The number of players per role.
    role_strats : int or ndarray
        The number of strategies per role.
    functions : int
        The number of functions to generate.
    input_prob : float, optional
        The probability of a strategy counting towards a function value.
    weight_prob : float, optional
        The probability of a function producing non-zero payoffs to a strategy.
    degree : int or [float], optional
        Either an integer specifying the degree or a list of the probabilities
        of degrees starting from one, e.g. 3 is the same as [0, 0, 1].
    """
    if isinstance(degree, int):
        degree = (0,) * (degree - 1) + (1,)
    max_degree = len(degree)

    def role_dist(functions, p):
        zeros = np.random.random((functions, max_degree)) * p
        terms = np.arange(p + 1)[:, None] - zeros[:, None]
        choices = np.random.choice(
            max_degree, (functions, p + 1), True, degree)
        terms[choices[..., None] < np.arange(max_degree)] = 1
        return terms.prod(2) / p ** choices

    return _random_aggfn(role_players, role_strats, functions, input_prob,
                         weight_prob, role_dist)


def sine_aggfn(role_players, role_strats, functions, *, input_prob=0.2,
               weight_prob=0.2, min_period=4, max_period=None):
    """Generate a random sinusodial AgfnGame

    Functions are generated by generating sinusoids with uniform random shifts
    and n periods in 0 to num_players, where n is chosen randomle between min_
    and max_period.

    Parameters
    ----------
    role_players : int or ndarray
        The number of players per role.
    role_strats : int or ndarray
        The number of strategies per role.
    functions : int
        The number of functions to generate.
    input_prob : float, optional
        The probability of a strategy counting towards a function value.
    weight_prob : float, optional
        The probability of a function producing non-zero payoffs to a strategy.
    min_period : int, optional
        The minimum number of periods to generate.
    max_period : int, optional
        The maximum number of periods to generate. If omitted or None, defaults
        to double min_period.
    """
    if max_period is None:
        max_period = min_period * 2

    def role_dist(functions, p):
        periods = (np.random.random(functions) * (max_period - min_period) +
                   min_period)
        offset = np.random.random(functions) * np.pi
        return np.sin((np.arange(p + 1)[:, None] * 2 * np.pi / p + offset) *
                      periods)

    return _random_aggfn(role_players, role_strats, functions, input_prob,
                         weight_prob, role_dist)


def _random_monotone_polynomial(functions, players, degree):
    """Generates a random monotone polynomial table"""
    coefs = (np.random.random((functions, degree + 1)) /
             players ** np.arange(degree + 1))
    powers = np.arange(players + 1) ** np.arange(degree + 1)[:, None]
    return coefs.dot(powers)


def congestion(num_players, num_facilities, num_required, *, degree=2):
    """Generate a congestion game

    A congestion game is a symmetric game, where there are a given number of
    facilities, and each player must choose to use some amount of them. The
    payoff for each facility decreases as more players use it, and a players
    utility is the sum of the utilities for every facility.

    In this formulation, facility payoffs are random polynomials of the number
    of people using said facility.

    Parameters
    ----------
    num_players : int > 1
        The number of players.
    num_facilities : int > 1
        The number of facilities.
    num_required : 0 < int < num_facilities
        The number of required facilities.
    degree : int > 0, optional
        Degree of payoff polynomials.
    """
    assert num_players > 1, "must have more than one player"
    assert num_facilities > 1, "must have more than one facility"
    assert 0 < num_required < num_facilities, \
        "must require more than zero but less than num_facilities"
    assert degree > 0, "degree must be greater than zero"

    function_inputs = utils.acomb(num_facilities, num_required)
    functions = -_random_monotone_polynomial(num_facilities, num_players,
                                             degree)

    facs = tuple(utils.prefix_strings('', num_facilities))
    strats = tuple('_'.join(facs[i] for i, m in enumerate(mask) if m)
                   for mask in function_inputs)
    return aggfn.aggfn_names(['all'], num_players, [strats], facs,
                             function_inputs.T, function_inputs, functions)


def local_effect(num_players, num_strategies, *, edge_prob=0.2):
    """Generate a local effect game

    In a local effect game, strategies are connected by a graph, and utilities
    are a function of the number of players playing our strategy and the number
    of players playing a neighboring strategy, hence local effect.

    In this formulation, payoffs for others playing our strategy are negative
    quadratics, and payoffs for playing other strategies are positive cubics.

    Parameters
    ----------
    num_players : int > 1
        The number of players.
    num_strategies : int > 1
        The number of strategies.
    edge_prob : float, optional
        The probability that one strategy affects another.
    """
    assert num_players > 1, "can't generate a single player game"
    assert num_strategies > 1, "can't generate a single strategy game"

    local_effect_graph = np.random.rand(
        num_strategies, num_strategies) < edge_prob
    np.fill_diagonal(local_effect_graph, False)
    num_neighbors = local_effect_graph.sum()
    num_functions = num_neighbors + num_strategies

    action_weights = np.eye(num_functions, num_strategies, dtype=float)
    function_inputs = np.eye(num_strategies, num_functions, dtype=bool)
    in_act, out_act = local_effect_graph.nonzero()
    func_inds = np.arange(num_strategies, num_functions)
    function_inputs[in_act, func_inds] = True
    action_weights[func_inds, out_act] = 1

    function_table = np.empty((num_functions, num_players + 1), float)
    function_table[:num_strategies] = -_random_monotone_polynomial(
        num_strategies, num_players, 2)
    function_table[num_strategies:] = _random_monotone_polynomial(
        num_neighbors, num_players, 3)
    return aggfn.aggfn(num_players, num_strategies, action_weights,
                       function_inputs, function_table)
